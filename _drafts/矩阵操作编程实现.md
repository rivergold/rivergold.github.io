# Basics

Most operations has `variable.func` and `package.func`.

**Numpy**

- `np.func`
- `np.ndarray.func`

**PyTorch**

- `torch.func`
- `torch.Tensor.func`

---

## View

### Numpy check is view or not

```python
a = np.array([[1, 2, 3], [4, 5, 6]])
# b is view of a
b = a.ravel()
print(b.base is a)
>>> True
print(np.may_share_memory(a, b))
>>> True
print(b.flags['OWNDATA'])
>>> False
```

**_Ref:_** [stackoverflow: How can I tell if NumPy creates a view or a copy?](https://stackoverflow.com/questions/11524664/how-can-i-tell-if-numpy-creates-a-view-or-a-copy)

<!--  -->
<br>

---

<br>
<!--  -->

# Common Operations

## flatten

Convert $n \times w$ to 1-D vector.

**Numpy**

```python
x = np.array([[1, 2, 3], [4, 5, 6]])
y = x.flatten()
print(x)
>>> array([1, 2, 3, 4, 5, 6])
```

Note: result of `np.ravel()` is same as `np.flatten`, but `np.ravel`'s return is **view**, which means if you change `y`, will also change `x`.

**_Ref:_** [stackoverflow: What is the difference between flatten and ravel functions in numpy?](https://stackoverflow.com/a/28930580/4636081)

**PyTorch**

```python
x = torch.tensor([[1, 2, 3], [4, 5, 6]])
y = x.flatten()
>>> tensor([1, 2, 3, 4, 5, 6])
```

Note: `torch.Tensor.view(-1)` has the same effect with `np.ndarray.ravel()`.

---

## squeeze

Remove dimensions which size is 1.

**Numpy**

```python
x = np.random.randn(1, 2, 1)
print(x)
>>> array([[[ 0.        ],
            [-0.52306498]]])
# Note: y is view of x
y = x.squeeze()
print(y, y.shape)
>>> [ 0.         -0.52306498] (2,)
```

**PyTorch**

```python
x = torch.randn(1, 2, 1)
print(x)
>>> tensor([[[ 0.0000],
             [-0.7718]]])

# Note: y is view of x
y = x.squeeze(x)
print(y, y.size())
>>> tensor([ 0.0000, -0.7718]) torch.Size([2])
```
