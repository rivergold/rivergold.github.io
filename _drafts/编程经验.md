# Callback Function

A callback function is a function which is:

- accessible by another function `F`, and

- is invoked in function `F`

> A "callback" is any function that is called by another function which takes the first function as a parameter.

**通俗理解:**

`A` tells `B` when some condition is met to call `C`.

`C` is the **callback function**. `A` may be `main` function, `B` accept `C` as parameter and call `C` when some condition is met.

主程序`A`告诉一个函数`B`在某种情况满足时下，请执行函数`C`。 函数`C`为回调函数。一般`C`会作为参数传递给`B`。

E.G.

Keras callback function during training

```python
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2,
                              patience=5, min_lr=0.001)
model.fit(X_train, Y_train, callbacks=[reduce_lr])
```

**_Ref:_** [Keras Documentation: Usage of callbacks](https://keras.io/callbacks/)

**_References:_**

- [stackoverflow: What is a callback function](https://stackoverflow.com/questions/824234/what-is-a-callback-function)

- [stackoverflow: How to explain callbacks in plain english? How are they different from calling one function from another function?](https://stackoverflow.com/questions/9596276/how-to-explain-callbacks-in-plain-english-how-are-they-different-from-calling-o/9652434#9652434)

- [知乎: 回调函数（callback）是什么？](https://www.zhihu.com/question/19801131/answer/27459821)

<!-- - [Blog: Using Python decorators for registering callbacks](http://curiosityhealsthecat.blogspot.com/2013/07/using-python-decorators-for-registering_8614.html) -->

<!--  -->
<br>

---

<br>
<!--  -->

# Hooking Mechanism

**形象的理解: 相当于插件, 为现有代码加入功能**

**_Ref:_** [知乎: pytorch 中的钩子（Hook）有何作用？](https://www.zhihu.com/question/61044004/answer/294829738)

## Relationship between Hook and Callback

Callback is a method to implement hook programming.

**_Ref:_** [stackoverflow: What is meant by the term “hook” in programming?](https://stackoverflow.com/a/467568/4636081)

<!-- **Hook: 拦截消息并进行处理的函数**

**理解:** 当某个消息被发出时，hook 会捕捉到该消息并进行执行某些代码。

**_References:_**

- [知乎: pytorch 中的钩子（Hook）有何作用？](https://www.zhihu.com/question/61044004)
- [CSDN: 钩子(hook)编程](https://blog.csdn.net/mingojiang/article/details/7908818)
- [简书: 程序猿口中的 Hook 是什么意思？](https://www.jianshu.com/p/0eeb3885b2e1) -->

---

## Example

**_Ref:_** [CSDN: python 学习之路--hook(钩子原理和使用)](https://blog.csdn.net/Mybigkid/article/details/78383898)

---

## :bulb:Hook Implementation in Python

1. 编写`BaseHook`
2. 为需要使用 hook 的类编写`register_hook`函数
3. 为需要使用 hook 的类编写`call_hook`函数

E.g.

```python
# BaseHook
class BaseHook(object):
    def before_train_epoch(self):
        pass

    def after_train_epoch(self):
        pass
```

```python
# Trainer
class Trainer(object):
    def __init__(self):
        self._hooks = []

    def register_hook(self, hook):
        # TODO: 如果hook有优先级，可以使用优先级队列
        self._hooks.append(hook)

    def _call_hook(self, func_type: str):
        for hook in self._hooks:
            getattr(hook, func_type)(self)

    def train(self):
        self._call_hook('before_train_epoch')
```

**_References:_**

- [Github: facebookresearch/detectron2](https://github.com/facebookresearch/detectron2/blob/ef096f9b2fbedca335f7476b715426594673f463/detectron2/engine/train_loop.py#L76)
- [Github: open-mmlab/mmcv](https://github.com/open-mmlab/mmcv/blob/ead4bc39bb9c9527a0440e30e59070901b7c121d/mmcv/runner/runner.py#L228)

<!--  -->
<br>

---

<br>
<!--  -->

# Model Parallelism & Data Parallelism

- 模型并行（model parallelism）:分布式系统中的不同机器（GPU/CPU 等）负责网络模型的不同部分 —— 例如，神经网络模型的不同网络层被分配到不同的机器，或者同一层内部的不同参数被分配到不同机器

- 数据并行（ data parallelism ）：不同的机器有同一个模型的多个副本，每个机器分配到不同的数据，然后将所有机器的计算结果按照某种方式合并

**_Ref:_** [CSDN: 分布式机器学习系统笔记（一）——模型并行，数据并行，参数平均，ASGD](https://blog.csdn.net/xbinworld/article/details/74781605)

<!--  -->
<br>

---

<br>
<!--  -->

# C++ Pimpl

**Pointer to implementation**

## Blogs

- [CSDN: 编译防火墙——C++的 Pimpl 惯用法解析](https://blog.csdn.net/lihao21/article/details/47610309)

**总结:** 定义一个接口类，在接口类中有一个 private 的指针，该指针用于指向实现具体函数功能的类的 object。

- [ ] add an example

---

## C++ Code build dynamic library without third-party lib include files

**_References:_**

- [知乎: 如何写 C++代码，才能在封装成 Dll 的同时，自己程序包含的额外头文件不用加载进来？](https://www.zhihu.com/question/336227826/answer/757634065?hb_wx_block=0&utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=37839882420224)

<!--  -->
<br>

---

<br>
<!--  -->

# Zero-cost Abstraction

E.g in PyTorch JIT: For example, if you have a loop in your model, it will get unrolled in the trace, inserting a copy of the loop body for as many times as the loop ran. This opens up opportunities for zero-cost abstraction (e.g. you can loop over modules, and the actual trace will be loop-overhead free!)

**注:** loop-overhead: 循环开销

**_References:_**

- [PyTorch Blog: The road to 1.0: production ready PyTorch - TRACING MODE](https://pytorch.org/blog/the-road-to-1_0/#tracing-mode)

- [云导播: inline 的优劣](https://m.ydaobo.com/wenzhang/84644.html)

<!--  -->
<br>

---

<br>
<!--  -->

# 深度学习框架的前端和后端

目前的深度学习框架都采用了前、后端的形式，C++作为后端，Python 作为前端

<!--  -->
<br>

---

<br>
<!--  -->

# Naming

## Blog

- [hackernoon: The art of naming variables](https://hackernoon.com/the-art-of-naming-variables-52f44de00aad)

## Naming Boolean Variable

- `is_`: 是不是
- `can_`: 能不能
- `has_`: 有没有
- `enable_`: 要不要

<!--  -->
<br>

---

<br>
<!--  -->

# InterProcess Communication (IPC)

进程间通信

机器学习模型的分布式调用系统可以基于 IPC 进行实现

RPC 是远程的 IPC 实现

**_References:_**

- [简书: 进程间通信 IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)

- [stackoverflow: Is there a difference between RPC and IPC?](https://stackoverflow.com/questions/2161674/is-there-a-difference-between-rpc-and-ipc)

- [CSDN: 进程间通信 IPC、LPC、RPC](https://blog.csdn.net/lanchunhui/article/details/50885423)

<!--  -->
<br>

---

<br>
<!--  -->

# 变量命名

- [单词缩写查找网站 abbreviations.com](https://www.abbreviations.com/abbreviation/index)

- threshold: `thold`
- index: `idx`

<!--  -->
<br>

---

<br>
<!--  -->

# RAII

Resource Acquisition Is Initialization

RAII 的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源

**_References:_**

- [wiki: RAII](https://zh.wikipedia.org/wiki/RAII)
- [简书: C++中的 RAII 机制](https://www.jianshu.com/p/b7ffe79498be)

# Handle and Handler

> A handle is an abstract reference to a resource.

Handler is a callback function

**_References:_**

- :thumbsup:[博客园: 闲话 handle 和 handler](https://www.cnblogs.com/idorax/p/6414007.html)

<!--  -->
<br>

---

<br>
<!--  -->

# :thumbsup:[Tool]Sourcetrail

An awesome source code reading tool for all platforms.

- [Home](https://www.sourcetrail.com/)

**_References:_**

- [V2EX: 你们一般都用啥工具看源代码呀？](https://www.v2ex.com/t/528588)

<!--  -->
<br>

---

<br>
<!--  -->

# :thumbsup:环境部署时，如果需要第三方可执行文件，可以考虑使用编译好的 static lib

E.g.

工程需要 ffmpeg，且对该 ffmpeg 有一定要求：例如需要`enable x264, libmp3lame`来读写 H264 的视频和 MP3 的音频。但通过`yum`，`apt`或者是`conda`这种包管理器无法直接安装这种相对而言比较特殊的库是，可以考虑从网上下载编译好的 static 版本的 ffmpeg 或者自己编译处 static 的库。

<!--  -->
<br>

---

<br>
<!--  -->

# Registry System 注册机制

- registry: 注册处
- register: n. 注册 v. 注册

**_References:_**

- [Detectron2](https://github.com/facebookresearch/detectron2/blob/fe2bbd88f99294ddb8162625ebbd9cde93781e00/detectron2/modeling/meta_arch/build.py#L2)
- [mmdetection](https://github.com/open-mmlab/mmdetection/blob/d2483e15fc48b4166815c15a6e12be864bcc521a/mmdet/models/builder.py#L4)

<!--  -->
<br>

---

<br>
<!--  -->

# Process vs Thread

总结：

- 进程是分配资源的最小单位，线程是程序执行的最小单位
- 进程与进程之间的内存是独立的，线程与线程之间的内存是共享的

**_References:_**

- [Blog: 一道面试题：说说进程和线程的区别](https://foofish.net/thread-and-process.html)
- [stackoverflow: What is the difference between a process and a thread?](https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread)

<!--  -->
<br>

---

<br>
<!--  -->

# Coroutines

**_References:_**

- [程序员小灰: 协程](https://www.itcodemonkey.com/article/4620.html)

## Why use coroutines

**_References:_**

- [Blog: 破解 Kotlin 协程 番外篇(1) - 协程为什么被称为『轻量级线程』？](https://mp.weixin.qq.com/s?__biz=MzU4NzIzNDU0Mg==&mid=2247483725&idx=1&sn=456ee0fc2570372fe1a8762d6997eebc&chksm=fdee6cccca99e5daa2559f9bf92107752cb189ec97fd77b3d12ed61a57bda946a3052120780e&mpshare=1&scene=1&srcid=&sharer_sharetime=1575985157083&sharer_shareid=cc363ceb86aab466ef27b423dcb88157#rd)

<!--  -->
<br>

---

<br>
<!--  -->

# Synchronous & Asynchronous, Blocking & Unblocking

**_References:_**

- [Blog: Network Programming: Blocking & Non-blocking, Synchronous & Asynchronous](https://magickaichen.com/unblock-block/)

> @Tornado doc: An asynchronous function returns before it is finished

**_References:_**

- [Tornado doc: Asynchronous and non-Blocking I/O](https://www.tornadoweb.org/en/stable/guide/async.html#asynchronous-and-non-blocking-i-o)

<!--  -->
<br>

---

<br>
<!--  -->

# Asynchronous I/O

> @wiki: In computer science, asynchronous I/O (also non-sequential I/O) is a form of input/output processing that permits other processing to continue before the transmission has finished.

> @rivergold: 异步函数/服务/IO，该函数/服务/IO 再被调用时，会立即返回一个值，之后自己处理相关计算，并且保证调用方不会一直等待返回结果。当处理完成时，会采用其他方式告知调用方。

<!--  -->
<br>

---

<br>
<!--  -->

# Asynchronous Programming

**_References:_**

- :thumbsup::thumbsup::thumbsup:[简书: Python 黑魔法 --- 异步 IO（ asyncio） 协程](https://www.jianshu.com/p/b5e347b3a17c)
- :thumbsup:[Real Python: Getting Started With Async Features in Python](https://realpython.com/python-async-features/)
