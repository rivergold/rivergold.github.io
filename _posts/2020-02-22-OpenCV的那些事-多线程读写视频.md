---
title: "OpenCV的那些事-多线程读写视频"
last_modified_at: 2020-02-22
categories:
  - OpenCV
tags:
  - OpenCV
  - Python
---

基于 OpenCV 采用多线程读写视频，降低因 I/O 操作导致整个系统速度降低的影响。

## Introduction

读写视频是一个相对较慢的 I/O 操作，如果整个系统中有大量需要读写视频的操作，或者需要批量处理很多视频时，单线程实现的代码会因为繁重的 I/O 操作严重影响到系统的处理速度。因此，我们可以采用并发的方式，使用多线程的方式读写视频，从而提升系统的处理效率。

> @rivergold: 从始到终只有一个`process object`，多个线程会轮询访问该 object，虽然在 process 的计算上不是并行的，但是在 I/O 操作上实现了并行，从而达到了加速的目的。

这里我们已最简单的系统实现作为举例，系统的主要功能为三分部分：

- 读取视频帧： I/O 操作，`VideoReader`
- 高斯模糊帧图像：计算操作， `GaussianBlurer`
- 写入视频：I/O 操作，`VideoWriter`

## Implementation

`VideoReader`

```python
class VideoReader(object):
    def __init__(self, in_video_path=None):
        self.video_path = in_video_path
        self._video = None
        self.fps = None
        self.w = None
        self.h = None
        self.num_frame = None
        self.frame_id = None

        if in_video_path:
            self.load(in_video_path)

    def load(self, in_video_path):
        self.release()
        self.video_path = in_video_path
        self._video = cv2.VideoCapture(in_video_path)

        self.fps = self._video.get(cv2.CAP_PROP_FPS)
        self.w = int(self._video.get(3))
        self.h = int(self._video.get(4))
        self.num_frame = int(self._video.get(cv2.CAP_PROP_FRAME_COUNT))

    def set_start_frame(self, frame_id):
        self._video.set(cv2.CAP_PROP_POS_FRAMES, frame_id)

    def get_next_frame(self):
        rev, frame = self._video.read()
        if rev:
            return frame
        else:
            return None

    def release(self):
        if self._video:
            self._video.release()
            self._video = None
```

`GaussianBlurer`

```python
class GaussianBlurer(object):
    def process(self, img):
        out_img = cv2.GaussianBlur(img, (5,5), borderType=cv2.BORDER_DEFAULT)
        return out_img
```

`VideoWriter`

```python
class VideoWriter(object):
    def __init__(self,
                 out_path,
                 video_w,
                 video_h,
                 fps=25):
        self._mode = mode
        self._w = video_w
        self._h = video_h
        self._fps = fps

        self._video = cv2.VideoWriter(out_path,
                                      cv2.VideoWriter_fourcc(*encoding),
                                      self._fps, (self._w, self._h))

    def write_frame(self, frame):
        assert (frame.shape[1] == self._w and frame.shape[0] == self._h)
        self._video.write(frame)

    def release(self):
        self._video.release()
```

在运行多线程处理之前，我们先需要计算每个线程需要处理的 frame id 分别是多少，这里我们采用平均分配的方式:

```python
def split_video_frame_sequence(num_frames, num_parts):
    num_each_part = math.floor(num_frames / num_parts)
    start_end_frame_ids = [[i * num_each_part, (i + 1) * num_each_part]
                           for i in range(num_parts - 1)]
    start_end_frame_ids.append([(num_parts - 1) * num_each_part, num_frames])
    return start_end_frame_ids
```

根据`num_parts`和`num_frames`计算出每个线程需要处理的起始帧号和结束帧号。

之后，我们使用 Python 的`concurrent`包的`futuers`和`ThreadPoolExecutor`实现多线程处理，并且使用 ffmpeg 将多个分段处理好的视频进行拼接。

```python
import subprocess

def run_command(command):
    try:
        subprocess.check_call(command, shell=True, executable='/bin/bash')
    except Exception as e:
        raise ValueError('Run subcommand error: {}'.format(e))

def concat_video(video_paths, tmp_dir, out_video_path):
    concat_txt = Path(tmp_dir) / '{}.txt'.format(get_current_strtime())
    with concat_txt.open('w', encoding='utf-8') as f:
        for video_path in video_paths:
            f.write('file {}\n'.format(video_path))
    command = 'ffmpeg -loglevel warning -y -f concat -safe 0 -i {} -c copy {}'.format(
        concat_txt.as_posix(), out_video_path)
    run_command(command)
    concat_txt.unlink()
```

```python
# run.py
from concurrent.futures import ThreadPoolExecutor, as_completed

def worker(self,
           processor,
           in_video_path,
           out_video_path,
           start_frame_id=None,
           end_frame_id=None):
    # Create video reader and writer
    video_reader = utils.video.VideoReader(in_video_path=in_video_path)
    video_writer = utils.video.VideoWriter(out_video_path,
                                           video_reader.w,
                                           video_reader.h,
                                           fps=video_reader.fps)
    # Set start frame id
    video_reader.set_start_frame(start_frame_id)
    # Process
    for frame_id in range(start_frame_id, end_frame_id):
        frame = video_reader.get_next_frame()
        out_frame = None
        if frame is None:
            break
        out_frame = processor.process(frame)
        video_writer.write_frame(out_frame)
    video_reader.release()
    video_writer.release()
    return out_video_path

def erase_video(self,
                in_video_path,
                out_video_path,
                mask_frame_generator,
                num_workers=4,
                out_video_bitrate=None):
    in_video_path = Path(in_video_path)
    in_video_name = in_video_path.name.split('.')[0]
    video_reader = utils.video.VideoReader(
        in_video_path=in_video_path.as_posix())

        # Calculate each part start and end frame id
        start_end_frame_id_list = split_video_frame_sequence(
            video_reader.num_frame, num_workers)

        # Multi threading
        thread_pool = ThreadPoolExecutor(max_workers=num_workers)
        futures = []
        tmp_video_paths = []
        for worker_id in range(num_workers):
            start_frame_id = start_end_frame_id_list[worker_id][0]
            end_frame_id = start_end_frame_id_list[worker_id][1]
            tmp_video_path = '{}-{}.mp4'.format(in_video_name, worker_id)
            # Submit task
            future = thread_pool.submit(
                worker,
                in_video_path.as_posix(),
                tmp_video_path.as_posix(),
                start_frame_id=start_frame_id,
                end_frame_id=end_frame_id)
            futures.append(future)
            tmp_video_paths.append(tmp_video_path.as_posix())

        for future in as_completed(futures):
            print(future)

        # Merge part video
        utils.video.concat_video(out_video_path,
                                 './',
                                 tmp_video_no_audio_path.as_posix())
```

## Experiment

这里是对多线程并发处理的速度对比

```shell
Total num: 88
1 thread: Process time is 46.20582628250122
4 thread: Process time is 34.412250995635986
8 thread: Process time is 26.82486081123352
```
